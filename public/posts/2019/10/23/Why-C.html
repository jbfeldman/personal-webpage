<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Why Build a Website in C? | Jonah Feldman’s personal website</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Why Build a Website in C?" />
<meta name="author" content="Jonah Feldman" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="There are a plethora of ways to start a website nowadays. For non-developers, services like wix let you build a website without even knowing a smidge of HTML or CSS. If you want to flex your HTML, CSS, and JS skills without worrying about setting up a server, services like wix (or even github) will host your sites for extremely cheap or even free. For those doing backend web development, common frameworks like Ruby on Rails, NodeJS, and Flask let you create dynamic web applications. Services like Heroku or AWS’s beanstalk let you deploy those services without worrying about the nitty gritty of opening port 80 or encryping your traffic. If you want to work even further down the stack, you can spin up your own web server using apache, nginx, or other production-level services. But what about creating your own server from scratch? C can do that! C lets you open sockets to listen on TCP ports. Once you read in the TCP stream, you can parse the information and send appropriately formatted responses to create your own HTTP server. Properly speaking, this project exists at both the layer of the server and the web applications. Future iterations of this server will hopefully create a cleaner distinction between the server and the application. But Seriously, why? Creating a personal website is a bit of a boring project, especially for people like me that aren’t especially interested in the UI/UX side of things. So making a C-based website was a chance to apply a lot of concepts I already understood in a fun project. Plus, it would make it take a lot longer and make it more of a serious project. More than keeping me interested through the dullwork of centering headers, writing a C backend helps one get a lot more thorough knowledge of TCP and HTTP protocols and behavior. Although Mozilla has some good stuff, most documentation on HTTP protocols isn’t great because it assumes you’re using a web framework that has a built in parser and that you don’t need to deal with the raw byte streams. As a result, you get tripped up by a lot of little weird stuff (why do HTTP headers end each line with \r\n?). And as corny as this sounds, each mistake is a chance to learn. It turns out you can’t overlook the content-length field in an HTTP response head; web browsers will start throwing up all sorts of nonsense if you do Are there any downsides to writing in C? You betcha. You really feel a lot of the C constraints, especially not having access to classes. This especially bites when dealing with HTTP headers, because having access to dictionaries would make it a much easier task. However, I don’t want to build a hashtable just for convenience, and I don’t feel like figuring out/trusting an open-source one (this may change if/when I build a cache, as hash tables will be great to improve cache performance). Where C sucks the most in this project by far is string parsing. Dealing with strings in C is awful compared to high-level languages like Python and Javascript, and even C++ has way better functionality to deal with them. I’m reduced to cobbling together wonky logic using strtok() and strstr(). I’ve been seriously tempted to throw in some C++ to deal with the strings (since all C code works in a C++ compiler), but that feels like cheating so I’ve perservered in C. Wait I found other Simple C-based HTTP servers that looks better yours… Well, you don’t have to rub it in. Seriously, I’m not claiming to be the best at this, and I don’t think I’m going to be putting nginx out of business any time soon. One thing that does differentiates my code from a lot of quick-and-dirty C servers online is that I put a lot of emphasis on modularity and readability in my code. While this sometimes leads to a lot of unnecessary verbosity, it makes updating the code a lot easier in the future." />
<meta property="og:description" content="There are a plethora of ways to start a website nowadays. For non-developers, services like wix let you build a website without even knowing a smidge of HTML or CSS. If you want to flex your HTML, CSS, and JS skills without worrying about setting up a server, services like wix (or even github) will host your sites for extremely cheap or even free. For those doing backend web development, common frameworks like Ruby on Rails, NodeJS, and Flask let you create dynamic web applications. Services like Heroku or AWS’s beanstalk let you deploy those services without worrying about the nitty gritty of opening port 80 or encryping your traffic. If you want to work even further down the stack, you can spin up your own web server using apache, nginx, or other production-level services. But what about creating your own server from scratch? C can do that! C lets you open sockets to listen on TCP ports. Once you read in the TCP stream, you can parse the information and send appropriately formatted responses to create your own HTTP server. Properly speaking, this project exists at both the layer of the server and the web applications. Future iterations of this server will hopefully create a cleaner distinction between the server and the application. But Seriously, why? Creating a personal website is a bit of a boring project, especially for people like me that aren’t especially interested in the UI/UX side of things. So making a C-based website was a chance to apply a lot of concepts I already understood in a fun project. Plus, it would make it take a lot longer and make it more of a serious project. More than keeping me interested through the dullwork of centering headers, writing a C backend helps one get a lot more thorough knowledge of TCP and HTTP protocols and behavior. Although Mozilla has some good stuff, most documentation on HTTP protocols isn’t great because it assumes you’re using a web framework that has a built in parser and that you don’t need to deal with the raw byte streams. As a result, you get tripped up by a lot of little weird stuff (why do HTTP headers end each line with \r\n?). And as corny as this sounds, each mistake is a chance to learn. It turns out you can’t overlook the content-length field in an HTTP response head; web browsers will start throwing up all sorts of nonsense if you do Are there any downsides to writing in C? You betcha. You really feel a lot of the C constraints, especially not having access to classes. This especially bites when dealing with HTTP headers, because having access to dictionaries would make it a much easier task. However, I don’t want to build a hashtable just for convenience, and I don’t feel like figuring out/trusting an open-source one (this may change if/when I build a cache, as hash tables will be great to improve cache performance). Where C sucks the most in this project by far is string parsing. Dealing with strings in C is awful compared to high-level languages like Python and Javascript, and even C++ has way better functionality to deal with them. I’m reduced to cobbling together wonky logic using strtok() and strstr(). I’ve been seriously tempted to throw in some C++ to deal with the strings (since all C code works in a C++ compiler), but that feels like cheating so I’ve perservered in C. Wait I found other Simple C-based HTTP servers that looks better yours… Well, you don’t have to rub it in. Seriously, I’m not claiming to be the best at this, and I don’t think I’m going to be putting nginx out of business any time soon. One thing that does differentiates my code from a lot of quick-and-dirty C servers online is that I put a lot of emphasis on modularity and readability in my code. While this sometimes leads to a lot of unnecessary verbosity, it makes updating the code a lot easier in the future." />
<link rel="canonical" href="http://localhost:4000/posts/2019/10/23/Why-C.html" />
<meta property="og:url" content="http://localhost:4000/posts/2019/10/23/Why-C.html" />
<meta property="og:site_name" content="Jonah Feldman’s personal website" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-10-23T20:00:00-04:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Why Build a Website in C?","dateModified":"2019-10-23T20:00:00-04:00","datePublished":"2019-10-23T20:00:00-04:00","url":"http://localhost:4000/posts/2019/10/23/Why-C.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/2019/10/23/Why-C.html"},"author":{"@type":"Person","name":"Jonah Feldman"},"description":"There are a plethora of ways to start a website nowadays. For non-developers, services like wix let you build a website without even knowing a smidge of HTML or CSS. If you want to flex your HTML, CSS, and JS skills without worrying about setting up a server, services like wix (or even github) will host your sites for extremely cheap or even free. For those doing backend web development, common frameworks like Ruby on Rails, NodeJS, and Flask let you create dynamic web applications. Services like Heroku or AWS’s beanstalk let you deploy those services without worrying about the nitty gritty of opening port 80 or encryping your traffic. If you want to work even further down the stack, you can spin up your own web server using apache, nginx, or other production-level services. But what about creating your own server from scratch? C can do that! C lets you open sockets to listen on TCP ports. Once you read in the TCP stream, you can parse the information and send appropriately formatted responses to create your own HTTP server. Properly speaking, this project exists at both the layer of the server and the web applications. Future iterations of this server will hopefully create a cleaner distinction between the server and the application. But Seriously, why? Creating a personal website is a bit of a boring project, especially for people like me that aren’t especially interested in the UI/UX side of things. So making a C-based website was a chance to apply a lot of concepts I already understood in a fun project. Plus, it would make it take a lot longer and make it more of a serious project. More than keeping me interested through the dullwork of centering headers, writing a C backend helps one get a lot more thorough knowledge of TCP and HTTP protocols and behavior. Although Mozilla has some good stuff, most documentation on HTTP protocols isn’t great because it assumes you’re using a web framework that has a built in parser and that you don’t need to deal with the raw byte streams. As a result, you get tripped up by a lot of little weird stuff (why do HTTP headers end each line with \\r\\n?). And as corny as this sounds, each mistake is a chance to learn. It turns out you can’t overlook the content-length field in an HTTP response head; web browsers will start throwing up all sorts of nonsense if you do Are there any downsides to writing in C? You betcha. You really feel a lot of the C constraints, especially not having access to classes. This especially bites when dealing with HTTP headers, because having access to dictionaries would make it a much easier task. However, I don’t want to build a hashtable just for convenience, and I don’t feel like figuring out/trusting an open-source one (this may change if/when I build a cache, as hash tables will be great to improve cache performance). Where C sucks the most in this project by far is string parsing. Dealing with strings in C is awful compared to high-level languages like Python and Javascript, and even C++ has way better functionality to deal with them. I’m reduced to cobbling together wonky logic using strtok() and strstr(). I’ve been seriously tempted to throw in some C++ to deal with the strings (since all C code works in a C++ compiler), but that feels like cheating so I’ve perservered in C. Wait I found other Simple C-based HTTP servers that looks better yours… Well, you don’t have to rub it in. Seriously, I’m not claiming to be the best at this, and I don’t think I’m going to be putting nginx out of business any time soon. One thing that does differentiates my code from a lot of quick-and-dirty C servers online is that I put a lot of emphasis on modularity and readability in my code. While this sometimes leads to a lot of unnecessary verbosity, it makes updating the code a lot easier in the future.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jonah Feldman's personal website" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Home</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
          <a class="page-link" href="/experience.html">Experience</a><a class="page-link" href="/about.html">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Why Build a Website in C?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-10-23T20:00:00-04:00" itemprop="datePublished">Oct 23, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>There are a plethora of ways to start a website nowadays. For non-developers, services like <a href="https://www.wix.com/">wix</a> let you build a website without even knowing a smidge of HTML or CSS. If you want to flex your HTML, CSS, and JS skills without worrying about setting up a server, services like wix (or even github) will host your sites for extremely cheap or even free.  For those doing backend web development, common frameworks like Ruby on Rails, NodeJS, and Flask let you create dynamic web applications. Services like Heroku or AWS’s beanstalk let you deploy those services without worrying about the nitty gritty of opening port 80 or encryping your traffic.  If you want to work even further down the stack, you can spin up your own web server using apache, nginx, or other production-level services.</p>

<p>But what about creating your own server from scratch? C can do that! C lets you open sockets to listen on TCP ports.  Once you read in the TCP stream, you can parse the information and send appropriately formatted responses to create your own HTTP server.</p>

<p>Properly speaking, this project exists at both the layer of the server and the web applications.  Future iterations of this server will hopefully create a cleaner distinction between the server and the application.</p>

<h2 id="but-seriously-why">But Seriously, why?</h2>

<p>Creating a personal website is a bit of a boring project, especially for people like me that aren’t especially interested in the UI/UX side of things. So making a C-based website was a chance to apply a lot of concepts I already understood in a fun project.  Plus, it would make it take a lot longer and make it more of a serious project.</p>

<p>More than keeping me interested through the dullwork of centering headers, writing a C backend helps one get a lot more thorough knowledge of TCP and HTTP protocols and behavior.  Although <a href="https://developer.mozilla.org/en-US/">Mozilla</a> has some good stuff, most documentation on HTTP protocols isn’t great because it assumes you’re using a web framework that has a built in parser and that you don’t need to deal with the raw byte streams.  As a result, you get tripped up by a lot of little weird stuff (why do HTTP headers end each line with <code class="highlighter-rouge">\r\n</code>?). And as corny as this sounds, each mistake is a chance to learn.  It turns out you can’t overlook the <code class="highlighter-rouge">content-length</code> field in an HTTP response head; web browsers will start throwing up all sorts of nonsense if you do</p>

<h2 id="are-there-any-downsides-to-writing-in-c">Are there any downsides to writing in C?</h2>

<p>You betcha. You really feel a lot of the C constraints, especially not having access to classes. This especially bites when dealing with HTTP headers, because having access to dictionaries would make it a much easier task.  However, I don’t want to build a hashtable just for convenience, and I don’t feel like figuring out/trusting an open-source one (this may change if/when I build a cache, as hash tables will be great to improve cache performance).</p>

<p>Where C sucks the most in this project by far is string parsing.  Dealing with strings in C is awful compared to high-level languages like Python and Javascript, and even C++ has way better functionality to deal with them.  I’m reduced to cobbling together wonky logic using <code class="highlighter-rouge">strtok()</code> and <code class="highlighter-rouge">strstr()</code>. I’ve been seriously tempted to throw in some C++ to deal with the strings (since all C code works in a C++ compiler), but that feels like cheating so I’ve perservered in C.</p>

<h2 id="wait-i-found-other-simple-c-based-http-servers-that-looks-better-yours">Wait I found other Simple C-based HTTP servers that looks better yours…</h2>

<p>Well, you don’t have to rub it in.  Seriously, I’m not claiming to be the best at this, and I don’t think I’m going to be putting nginx out of business any time soon.</p>

<p>One thing that does differentiates my code from a lot of quick-and-dirty C servers online is that I put a lot of emphasis on modularity and readability in my code. While this sometimes leads to a lot of unnecessary verbosity, it makes updating the code a lot easier in the future.</p>

  </div><a class="u-url" href="/posts/2019/10/23/Why-C.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jonah Feldman&#39;s personal website</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jonah Feldman</li><li><a class="u-email" href="mailto:yohan.feldman@gmail.com">yohan.feldman@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jbfeldman"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> </a></li><li><a href="https://www.linkedin.com/in/jonah-feldman-937784152"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> </a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>

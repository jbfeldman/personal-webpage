<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-10-26T20:39:49-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jonah Feldman’s personal website</title><subtitle>This is my personal website! While the front-end is just the default Jekyll minima theme, the server backend is written entirely in C. Checkout the source code &lt;a href='https://github.com/jbfeldman/personal-webpage'&gt; here &lt;/a&gt; and create an issue if you notice anything wrong. Feel free to fork it and just change public folder to create your own C-based website!</subtitle><author><name>Jonah Feldman</name></author><entry><title type="html">Why Build a Website in C?</title><link href="http://localhost:4000/posts/2019/10/23/Why-C.html" rel="alternate" type="text/html" title="Why Build a Website in C?" /><published>2019-10-23T20:00:00-04:00</published><updated>2019-10-23T20:00:00-04:00</updated><id>http://localhost:4000/posts/2019/10/23/Why-C</id><content type="html" xml:base="http://localhost:4000/posts/2019/10/23/Why-C.html">&lt;p&gt;There are a plethora of ways to start a website nowadays. For non-developers, services like &lt;a href=&quot;https://www.wix.com/&quot;&gt;wix&lt;/a&gt; let you build a website without even knowing a smidge of HTML or CSS. If you want to flex your HTML, CSS, and JS skills without worrying about setting up a server, services like wix (or even github) will host your sites for extremely cheap or even free.  For those doing backend web development, common frameworks like Ruby on Rails, NodeJS, and Flask let you create dynamic web applications. Services like Heroku or AWS’s beanstalk let you deploy those services without worrying about the nitty gritty of opening port 80 or encryping your traffic.  If you want to work even further down the stack, you can spin up your own web server using apache, nginx, or other production-level services.&lt;/p&gt;

&lt;p&gt;But what about creating your own server from scratch? C can do that! C lets you open sockets to listen on TCP ports.  Once you read in the TCP stream, you can parse the information and send appropriately formatted responses to create your own HTTP server.&lt;/p&gt;

&lt;p&gt;Properly speaking, this project exists at both the layer of the server and the web applications.  Future iterations of this server will hopefully create a cleaner distinction between the server and the application.&lt;/p&gt;

&lt;h2 id=&quot;but-seriously-why&quot;&gt;But Seriously, why?&lt;/h2&gt;

&lt;p&gt;Creating a personal website is a bit of a boring project, especially for people like me that aren’t especially interested in the UI/UX side of things. So making a C-based website was a chance to apply a lot of concepts I already understood in a fun project.  Plus, it would make it take a lot longer and make it more of a serious project.&lt;/p&gt;

&lt;p&gt;More than keeping me interested through the dullwork of centering headers, writing a C backend helps one get a lot more thorough knowledge of TCP and HTTP protocols and behavior.  Although &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla&lt;/a&gt; has some good stuff, most documentation on HTTP protocols isn’t great because it assumes you’re using a web framework that has a built in parser and that you don’t need to deal with the raw byte streams.  As a result, you get tripped up by a lot of little weird stuff (why do HTTP headers end each line with &lt;code class=&quot;highlighter-rouge&quot;&gt;\r\n&lt;/code&gt;?). And as corny as this sounds, each mistake is a chance to learn.  It turns out you can’t overlook the &lt;code class=&quot;highlighter-rouge&quot;&gt;content-length&lt;/code&gt; field in an HTTP response head; web browsers will start throwing up all sorts of nonsense if you do&lt;/p&gt;

&lt;h2 id=&quot;are-there-any-downsides-to-writing-in-c&quot;&gt;Are there any downsides to writing in C?&lt;/h2&gt;

&lt;p&gt;You betcha. You really feel a lot of the C constraints, especially not having access to classes. This especially bites when dealing with HTTP headers, because having access to dictionaries would make it a much easier task.  However, I don’t want to build a hashtable just for convenience, and I don’t feel like figuring out/trusting an open-source one (this may change if/when I build a cache, as hash tables will be great to improve cache performance).&lt;/p&gt;

&lt;p&gt;Where C sucks the most in this project by far is string parsing.  Dealing with strings in C is awful compared to high-level languages like Python and Javascript, and even C++ has way better functionality to deal with them.  I’m reduced to cobbling together wonky logic using &lt;code class=&quot;highlighter-rouge&quot;&gt;strtok()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;strstr()&lt;/code&gt;. I’ve been seriously tempted to throw in some C++ to deal with the strings (since all C code works in a C++ compiler), but that feels like cheating so I’ve perservered in C.&lt;/p&gt;

&lt;h2 id=&quot;wait-i-found-other-simple-c-based-http-servers-that-looks-better-yours&quot;&gt;Wait I found other Simple C-based HTTP servers that looks better yours…&lt;/h2&gt;

&lt;p&gt;Well, you don’t have to rub it in.  Seriously, I’m not claiming to be the best at this, and I don’t think I’m going to be putting nginx out of business any time soon.&lt;/p&gt;

&lt;p&gt;One thing that does differentiates my code from a lot of quick-and-dirty C servers online is that I put a lot of emphasis on modularity and readability in my code. While this sometimes leads to a lot of unnecessary verbosity, it makes updating the code a lot easier in the future.&lt;/p&gt;</content><author><name>Jonah Feldman</name></author><summary type="html">There are a plethora of ways to start a website nowadays. For non-developers, services like wix let you build a website without even knowing a smidge of HTML or CSS. If you want to flex your HTML, CSS, and JS skills without worrying about setting up a server, services like wix (or even github) will host your sites for extremely cheap or even free. For those doing backend web development, common frameworks like Ruby on Rails, NodeJS, and Flask let you create dynamic web applications. Services like Heroku or AWS’s beanstalk let you deploy those services without worrying about the nitty gritty of opening port 80 or encryping your traffic. If you want to work even further down the stack, you can spin up your own web server using apache, nginx, or other production-level services. But what about creating your own server from scratch? C can do that! C lets you open sockets to listen on TCP ports. Once you read in the TCP stream, you can parse the information and send appropriately formatted responses to create your own HTTP server. Properly speaking, this project exists at both the layer of the server and the web applications. Future iterations of this server will hopefully create a cleaner distinction between the server and the application. But Seriously, why? Creating a personal website is a bit of a boring project, especially for people like me that aren’t especially interested in the UI/UX side of things. So making a C-based website was a chance to apply a lot of concepts I already understood in a fun project. Plus, it would make it take a lot longer and make it more of a serious project. More than keeping me interested through the dullwork of centering headers, writing a C backend helps one get a lot more thorough knowledge of TCP and HTTP protocols and behavior. Although Mozilla has some good stuff, most documentation on HTTP protocols isn’t great because it assumes you’re using a web framework that has a built in parser and that you don’t need to deal with the raw byte streams. As a result, you get tripped up by a lot of little weird stuff (why do HTTP headers end each line with \r\n?). And as corny as this sounds, each mistake is a chance to learn. It turns out you can’t overlook the content-length field in an HTTP response head; web browsers will start throwing up all sorts of nonsense if you do Are there any downsides to writing in C? You betcha. You really feel a lot of the C constraints, especially not having access to classes. This especially bites when dealing with HTTP headers, because having access to dictionaries would make it a much easier task. However, I don’t want to build a hashtable just for convenience, and I don’t feel like figuring out/trusting an open-source one (this may change if/when I build a cache, as hash tables will be great to improve cache performance). Where C sucks the most in this project by far is string parsing. Dealing with strings in C is awful compared to high-level languages like Python and Javascript, and even C++ has way better functionality to deal with them. I’m reduced to cobbling together wonky logic using strtok() and strstr(). I’ve been seriously tempted to throw in some C++ to deal with the strings (since all C code works in a C++ compiler), but that feels like cheating so I’ve perservered in C. Wait I found other Simple C-based HTTP servers that looks better yours… Well, you don’t have to rub it in. Seriously, I’m not claiming to be the best at this, and I don’t think I’m going to be putting nginx out of business any time soon. One thing that does differentiates my code from a lot of quick-and-dirty C servers online is that I put a lot of emphasis on modularity and readability in my code. While this sometimes leads to a lot of unnecessary verbosity, it makes updating the code a lot easier in the future.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2019/10/07/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2019-10-07T20:05:59-04:00</published><updated>2019-10-07T20:05:59-04:00</updated><id>http://localhost:4000/jekyll/update/2019/10/07/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/10/07/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>Jonah Feldman</name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>